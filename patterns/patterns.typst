#import "../template.typ": *

#show: doc => conf(author: "Fabio Lenherr", "Patterns and frameworks", "summary", doc)

#section("Pattern Definition")
- addresses a common problem
  - specifically why a problem is hard (*forces*)
- *generic solutions* that can be adapted
- describes benefits and liabilities
- gets a name, so we can talk about it

Note:
- patterns often depend on each other
  - sometimes extend each other
  - or implement parts of it
- are never completely alone -> always exist in environment

#section("GoF Great of Four")
#align(center, [#image("../Screenshots/2023_09_22_09_30_09.png", width: 70%)])

#subsection("Mediator")
#set text(size: 14pt)
Problem | *Coupling* -> too many objects interact with each other
Category | *Behavioral*
#align(center, [#image("../Screenshots/2023_09_29_09_12_31.png", width: 80%)])
#align(center, [#image("../Screenshots/2023_09_29_09_15_48.png", width: 80%)])
#set text(size: 11pt)
- Be careful with static, the structure can quickly become a too large monolith
  with too many colleagues.
- Mediator can be implemented as _Observer_ as well, the mediator is the
  observable and the colleagues are the observers.

#columns(2, [
  #text(green)[Benefits]
  - Colleague classes may become more reusable, low coupling
  - Centralizes control of communication between objects
  - Encapsulates protocols
  - Liabilities
  #colbreak()
  #text(red)[Liabilities]
  - Adds complexity
  - Single point of failure
  - Limits subclassing (of mediator class)
  - May result in hard maintainable monoliths
])

#subsection("Memento")
#set text(size: 14pt)
Problem | *History* -> Object should remember its own state
Category | *Behavioral*
Participants | Originator -> Object in question, Memento -> History, e.g. stack,
#align(center, [#image("../Screenshots/2023_09_29_09_21_19.png", width: 80%)])
Caretaker -> storage, e.g. database
#set text(size: 11pt)

- similar:
  - Serialization
  - Future Pattern

#columns(2, [
  #text(green)[Benefits]
  - Internal state of an object can be saved and restored at any time
  - Encapsulation of attributes is not harmed
  - State of objects can be restored later
  #colbreak()
  #text(red)[Liabilities]
  - Creates a complete copy of the object every time, no diffs
  - May require a lot of memory
  - No direct access to saved state, it must be restored first
])

#subsection("Singleton")
Problem | *Static Instance* -> only 1 object of this type should exist 
Category | *Creational*
#columns(2, [
  #text(green)[Benefits]
  - clean solution to single object 
  - solves dependencies including the singleton object
  - solves argument spam in functions
  #colbreak()
  #text(red)[Liabilities]
  - if built wrong can lead to needless mock implementations of a singleton -> mock singletons for tests 
  - can lead to race conditions -> not in rust 
  - might require getDB() calls
])

#subsection("Prototype")
Problem | *Inheritance problem* -> too many inheritances 
Category | *Creational*
Similar | *Trait / Interface*



