#import "../template.typ": *

#show: doc => conf(author: "Fabio Lenherr", "Experiments", "summary", doc)

#section("Base Idea")
the reason we do experiments, is to validate a *Hypothesis*, which is based on a
model of the real world.\
Aka, we think about a supposed way the world works, and then to test this
assumption, we create an experiment to compare the model world to the real
world.

*Note, experimenting is not randomly doing something, it has a purpose!*

#subsection("Mathematical Base")
*statistics* and *error calculation* is the base that covers:
- inaccuracies
- noise
- continuity

#subsection("Experiment Planning")
- keeps the amount of actual experiments low
- only change one factor at a time -> otherwise you can't tell what made the
  difference

#align(center, [#image("../Screenshots/2023_09_21_08_42_20.png", width: 50%)])

#section("Industrial Experiment Planning (Design of Experiments DOE)")
#columns(
  2,
  [
    - Complexity
      - high amount of factors or elements
      - lot of aspects
    - Trickyness (Kompliziertheit)
      - unknown, not understood or hard to describe mechanisms or connections
      - tendency to oversimplify
    - Noise
      - time variation
      - different results after same input
        - inconsistent system
    #colbreak()
    #align(center, [#image("../Screenshots/2023_09_21_08_50_46.png", width: 90%)])
  ],
)
- 1. Research of basics
- 2. Testing of hypothesis and theories
- 3. Development of new products
- 4. Creation of new processes
- 5. Optimization
  - of old processes
  - of cycle time
  - of process parameters
  - of product quality
  - of costs
  - of load
*Experiments can either be done on the real object/real world, or in a simulated
environment.*

#align(center, [#image("../Screenshots/2023_09_21_08_55_39.png", width: 70%)])
The idea here is that you never know the end result, and the object/world is
always considered to be a black box.\
You can never know the box fully until the end.\
Take into account:
- noise
  - unknown or known inaccuracies
  - often can't be removed
- input factors
  - this is the only thing we can truly influence
- error in measurements
  - we always make errors here, again either consciously or unconsciously

#subsection("Solving a real problem via statistics")
#align(center, [#image("../Screenshots/2023_09_21_08_58_58.png", width: 70%)])

#section("Terms")
#subsection("Target Values")
This refers to the result of the experiment.\
Can be measurements, calculated values(consider error propagation here).\
Multiple target values can be defined for an experiment.

#subsection("Influence Values")
- Control Values
  - turning knobs we can control
  - input parameters $x^i$
- Noise Values
  - can't be controlled by us
  - unknown value

#subsection("Factors and Factorlevels")
- *Factors*
  out of all values, we take the supposed relevant influence values for the
  experiment, these are called *factors*
- *Factorlevels*
  After choosing the factors, we have to define which values these factors are
  going to have in the experiment.\
  example, in a function graph, where are we in this graph? What values are
  relevant for the section we want to experiment on?
- *Quantitative factors (metric scale)*
  - Number values on the metric scale
- *Qualitative factors (nominal scale)*
  - Names, descriptions, labels

#subsection("Procedure of an experiment")
#align(center, [#image("../Screenshots/2023_09_21_09_08_21.png", width: 80%)])

#pagebreak()
#subsection("Analysis")
#columns(
  2,
  [
    analyze current situation
    #align(center, [#image("../Screenshots/2023_09_21_09_16_38.png", width: 90%)])
    #colbreak()
    Define goals of experiment
    #align(center, [#image("../Screenshots/2023_09_21_09_17_10.png", width: 90%)])
  ],
)
#columns(
  2,
  [
    Define Target Values
    #align(center, [#image("../Screenshots/2023_09_21_09_18_29.png", width: 90%)])
    #colbreak()
    Best Practice
    #align(center, [#image("../Screenshots/2023_09_21_09_18_58.png", width: 90%)])
  ],
)

#subsection("example")
#columns(
  2,
  [
    #align(center, [#image("../Screenshots/2023_09_21_09_22_31.png", width: 90%)])
    #colbreak()
    #align(center, [#image("../Screenshots/2023_09_21_09_22_57.png", width: 90%)])
  ],
)
#columns(
  2,
  [
    #align(center, [#image("../Screenshots/2023_09_21_09_23_13.png", width: 90%)])
    #colbreak()
    #align(center, [#image("../Screenshots/2023_09_21_09_23_27.png", width: 90%)])
  ],
)

#section("Error Calculation")
#subsection("Maximum Error")
- The worst case scenario
- *if you calculate the maximum error, the boundaries for the error must be known!*
  - e.g. it's not the max error if there is an error that can be worse than this!
  - same would be the case for the minimum error
#subsection("Probable Error")
- is a likely error
- *actual value does not need to be known, can be variable*
  - usually done with a spectrum
#subsection("Usage for error calculation")
- provide accuracy values
  - e.g. this tool is so and so accurate
- provide worst case scenarios -> maximum error

#subsection("Implicit Error")
Implicit errors are used in order to not always provide error calculations for
absolutely everything, especially when it is not necesarily useful or relevant.
In this case, the errors are implicitly added.\

Values of implicit errors:
- minimum: add 0.5(units) to the last digit
  - ex1: 0.002 -> +\- 0.0005 is the possible error
  - ex1: 1 -> +\- 0.5 is the possible error
- maximum: add 3 to 4(units) to the last digit
  - ex1: 0.002 -> +\- 0.004 is the possible error
  - ex1: 1 -> +\- 4 is the possible error

#subsection("The Absolute Error")
This error has a *unit*, namely the same that the measurement has. For example
if we want to measure the length of an object and we start the measurement at
15mm and end at 17mm with an error of 0.5mm, then the errors are added as
follows:\
14.5mm -> 17.5mm, aka subtract 0.5mm from bottom value and add 0.5 to top value.\
used for:
- #text(teal)[additions and subtractions]
  - the rectangle example of the implicit error -> absolute error

#subsection("The Relative Error")
This is derived from the absolute error, it is simply a percentage of the
original value which can be added or removed as error:\
#text(size: 14pt, [$m/e*100$]) *where _m_ is the measurement and _e_ is the absolute error*\
used for:
- #text(teal)[multiplications and divisions]
  - errors of multiplications are done with this as percentages can be converted to
    factors easily

#subsection("Partial Differentiation")
In the previous section, we said we can accumulate factors, this can be seen as
an example here. How do we calculate the error of y squared? Easy, take the
error of y twice!:\
Base calculation:\
#text(
  size: 14pt,
  [$E = (x y^2) / z -> Delta E / E = (Delta x) / x + 2 (Delta y) / y + (Delta z) / z$],
)\
easy way:\
#text(
  size: 14pt,
  [$y^2 -> y * y -> (Delta y) / y + (Delta y) / y -> 2 * Delta y$],
)\
or we can use differentiation...\
#text(
  size: 14pt,
  [$Delta E -> | (delta E) / (delta x) Delta x | + |(delta E) / (delta y) Delta y | + |(delta E) / (delta z) Delta z |$],
)
#align(center, [#image("../Screenshots/2023_09_28_09_19_13.png", width: 50%)])

#subsection("Usage of minimum and maximum values")
#text(red)[This is not a particularly useful idea, if this can't be applied easily, you should use partial differentiation!]\
#text(size: 14pt, [$E = (u - v) / (x  -  y) -> E_max = (u_max - v_max) / (x_max - y_max) -> Delta E = E_max - E$])

#subsection("Summary error")
#align(center, [#image("../Screenshots/2023_09_28_09_20_15.png", width: 80%)])

#subsection("Real world usage")
- create abstraction architecture for tests
  - should resemble real world
- create datasets
- measured values are influenced by stochastic influence values, interruptions and errors
- validate systems
- calculate rest error

